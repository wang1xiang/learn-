#### 引擎、运行时和调用堆栈的概述

- JavaScript 引擎的流行示例是谷歌的 V8 引擎，V8 引擎由两个部件组成：
  > - memory Heap(内存堆) - 内存分配的地方
  > - Call Stack(调用堆栈) - 代码执行的地方
- RunTime(运行时)
  > 有些浏览器的 API 经常被人们使用(比如 SetTimeout)，但是这些并不是引擎提供的，这些引擎之外的 API，我们称之为 Web API，比如 DOM、AJAX、setTimout 等等
  > 还包含事件循环和回调队列
- 调用栈
  > JavaScript 是单线程变成语言，因此只有一个调用堆栈，因此一次只能做一件事。调用栈是一种数据结构，记录了我们在程序中的位置，如果运行一个函数，他就会将其放到栈顶，当函数返回时，就会将此函数从栈中弹出
  ```js
  function bar() {
    console.log('s')
  }
  function foo() {
    bar()
  }
  foo()
  ```
  > 如上，当程序开始执行时，调用栈是空的，第一步调用 foo 函数，foo 函数进栈，foo 调用 bar，bar 函数进入栈，接着 bar 函数打印输出，出栈，bar 返回，foo 函数出栈(每一个进入栈的都被称为调用帧)
  > "堆栈溢出"当调用帧的数量达到调用栈的最大时就会发生，比如递归
  ```js
  function foo() {
    foo()
  }
  foo()
  ```
  > 每次调用都会添加相同的函数到调用堆栈中，最终会发生"堆栈溢出"(VM107:1 Uncaught RangeError: Maximum call stack size exceeded)
  > 所以，单线程运行代码有好有坏，好处是不用处理多线程中的复杂场景--如死锁，坏处是只有一个调用堆栈，当某段代码运行较慢时，会发生什么？继续...
- 并发和事件循环
  > 假如你希望在浏览器中使用 JavaScript 进行一些复杂的图像转换，这时候调用堆栈有函数要执行，浏览器不能做其他事情--堵塞，这意味着浏览器不能运行其他代码，它被卡住了，如果想在应用中使用流畅的页面效果，这就会产生问题。
  > 一旦浏览器开始处理调用队中的众多任务，可能会停止响应相当长一段时间，大多数浏览器会报一个错误，询问是否终止页面。
  > 那么，我们怎样才能在不阻塞 UI 和不使浏览器失去响应的情况下执行大量代码呢?解决方案是异步回调。

#### 深入 V8 引擎&编写优化代码的 5 个技巧

- JavaScript 引擎是执行 JavaScript 代码的程序或解释器。
- 为什么创建 V8 引擎？
  > V8 引擎由谷歌构建，使用 C++编写，与其他引擎不同的是 V8 也同样适用于流行的 nodeJs 中。最初设计是为了提高 web 浏览器中 JavaScript 执行的性能。
